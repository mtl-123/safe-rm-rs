// æ ¸å¿ƒä¾èµ–å¯¼å…¥
use clap::{Parser, Subcommand};
use chrono::{Duration, Local, NaiveDateTime, TimeZone};
use dirs::home_dir;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::fs;
use std::io::{self, Write};
use std::path::{Path, PathBuf};
use std::time::SystemTime;

// é…ç½®å¸¸é‡
const DEFAULT_EXPIRE_DAYS: i64 = 7;
const TRASH_DIR: &str = ".safe-rm/trash";
const META_FILE: &str = ".safe-rm/metadata.json";

#[derive(Parser, Debug)]
#[command(
    author = "Your Name <your.email@example.com>",
    version = "1.0.0",
    about = "Safe alternative to rm: move files to trash instead of permanent delete",
    long_about = r#"Safe rm (safe-rm) is a secure replacement for the native rm command that prevents accidental permanent file deletion.
Key features:
1. Moves files/directories to a trash directory (~/.safe-rm/trash) instead of deleting them
2. Supports restoring deleted files to their original paths
3. Auto-cleans expired files (default: 7 days)
4. Protects system directories from accidental deletion
5. Handles symlinks, regular files, and directories correctly

Basic usage:
  safe-rm del <file>          # Move file to trash
  safe-rm ls                  # List trash contents
  safe-rm res <trash-name>    # Restore file from trash
  safe-rm cln                 # Clean expired files
"#
)]
struct Cli {
    #[command(subcommand)]
    cmd: Commands,
}

#[derive(Subcommand, Debug)]
pub enum Commands {
    #[command(
        alias = "del",
        about = "Move files/directories to trash (recursive support)",
        long_about = r#"Move specified files or directories to the trash directory (~/.safe-rm/trash).
Files are not permanently deleted and can be restored later.
Supports batch deletion of multiple paths and custom expiration days.
System directories (e.g., /bin, /usr, /root) are protected by default - use -f to override.
Symlinks are handled as-is (only the link is moved, not the target)."#
    )]
    Delete {
        #[arg(
            required = true,
            help = "One or more paths to files/directories to move to trash",
            long_help = "Path(s) to the file or directory you want to delete (move to trash). Multiple paths can be specified separated by spaces."
        )]
        paths: Vec<PathBuf>,

        #[arg(
            short = 'd',
            long,
            default_value_t = DEFAULT_EXPIRE_DAYS,
            help = "Number of days until the file expires (default: 7)",
            long_help = "Set custom expiration days for the deleted files. After this period, the files will be automatically cleaned up from the trash. Default value is 7 days."
        )]
        expire_days: i64,

        #[arg(
            short = 'f',
            long,
            help = "Force delete - skip system directory protection check",
            long_help = "Force deletion of files in protected system directories (/bin, /sbin, /etc, /usr, /lib, /lib64, /root, /boot). Use this option with extreme caution as it may damage your system."
        )]
        force: bool,
    },

    #[command(
        alias = "res",
        about = "Restore files/directories from trash to original path",
        long_about = r#"Restore specified items from the trash directory back to their original locations.
Requires the trash name (from `safe-rm list` output) as input.
By default, will not overwrite existing files at the target path - use -f to force overwrite.
Supports batch restoration of multiple trash items."#
    )]
    Restore {
        #[arg(
            required = true,
            help = "One or more trash names to restore (from `safe-rm list`)",
            long_help = "Trash name(s) of the files/directories to restore. These names are generated by safe-rm (e.g., 'file.txt_1735689000000000000') and can be listed with `safe-rm list`."
        )]
        names: Vec<String>,

        #[arg(
            short = 'f',
            long,
            help = "Force restore - overwrite existing files at target path",
            long_help = "Force restoration even if a file/directory already exists at the original path. This will overwrite the existing file/directory with the one from trash."
        )]
        force: bool,
    },

    #[command(
        alias = "ls",
        about = "List all items in the trash directory with details",
        long_about = r#"List all files and directories currently in the trash (~/.safe-rm/trash).
Shows detailed information including:
- Trash name (used for restoration)
- File type (File/Directory/Symlink)
- Original path
- Deletion time
- Expiration days and remaining time until expiration
Use --expired to filter only items that have passed their expiration date."#
    )]
    List {
        #[arg(
            long,
            help = "Only show expired items in trash",
            long_help = "Filter the list to show only items that have passed their expiration date and are eligible for automatic cleanup."
        )]
        expired: bool,
    },

    #[command(
        alias = "cln",
        about = "Clean expired items from trash",
        long_about = r#"Manually clean up items from the trash directory.
By default, only removes items that have expired (based on their expiration days).
Use --all to remove ALL items from trash (ignores expiration status) - use with caution."#
    )]
    Clean {
        #[arg(
            short = 'a',
            long,
            help = "Clean ALL items (ignore expiration - CAUTION!)",
            long_help = "Clean all items from the trash directory, regardless of their expiration status. This is irreversible for items that haven't expired yet - use extreme caution."
        )]
        all: bool,
    },

    #[command(
        alias = "exp",
        about = "Check expiration information for a trash item",
        long_about = r#"Show detailed expiration information for a specific item in the trash.
Displays:
- Original path of the item
- Time it was deleted
- Exact expiration time
- Remaining time until expiration (or time since expiration if expired)"#
    )]
    Expire {
        #[arg(
            required = true,
            help = "Trash name to check expiration for",
            long_help = "Trash name of the item to check (from `safe-rm list` output, e.g., 'file.txt_1735689000000000000')."
        )]
        name: String,
    },

    #[command(
        alias = "empty",
        about = "Permanently empty the entire trash directory",
        long_about = r#"Permanently delete ALL items from the trash directory.
This operation is irreversible - all files in trash will be permanently deleted.
Requires confirmation by default - use --yes to skip confirmation."#
    )]
    Empty {
        #[arg(
            short = 'y',
            long,
            help = "Skip confirmation prompt - empty trash immediately",
            long_help = "Bypass the confirmation prompt and immediately empty the entire trash directory. All items will be permanently deleted with no way to recover them."
        )]
        yes: bool,
    },
}

#[derive(Serialize, Deserialize, Debug, Clone)]
struct FileMeta {
    original_path: PathBuf,
    trash_path: PathBuf,
    delete_time: String,
    expire_days: i64,
    file_type: FileType,
}

#[derive(Serialize, Deserialize, Debug, Clone, Copy)]
enum FileType {
    File,
    Dir,
    Symlink,
}

// é€’å½’å¤åˆ¶ï¼šä¿ç•™ç¬¦å·é“¾æ¥
fn copy_path(src: &Path, dst: &Path) -> io::Result<()> {
    let meta = fs::symlink_metadata(src)?;
    if meta.file_type().is_dir() {
        fs::create_dir_all(dst)?;
        for entry in fs::read_dir(src)? {
            let entry = entry?;
            let dst_entry = dst.join(entry.file_name());
            copy_path(&entry.path(), &dst_entry)?;
        }
    } else if meta.file_type().is_symlink() {
        let target = fs::read_link(src)?;
        std::os::unix::fs::symlink(target, dst)?;
    } else {
        fs::copy(src, dst)?;
    }
    Ok(())
}

// ç»Ÿä¸€åˆ é™¤
fn remove_path(path: &Path) -> io::Result<()> {
    let meta = fs::symlink_metadata(path)?;
    if meta.file_type().is_dir() {
        fs::remove_dir_all(path)
    } else {
        fs::remove_file(path)
    }
}

// åŠ è½½å…ƒæ•°æ®
fn load_metadata(meta_file: &Path) -> HashMap<String, FileMeta> {
    if !meta_file.exists() {
        return HashMap::new();
    }
    match fs::read_to_string(meta_file) {
        Ok(content) => match serde_json::from_str(&content) {
            Ok(meta) => meta,
            Err(e) => {
                eprintln!("âš ï¸  Metadata corrupted: {}, resetting", e);
                HashMap::new()
            }
        },
        Err(e) => {
            eprintln!("âš ï¸  Failed to read metadata: {}, resetting", e);
            HashMap::new()
        }
    }
}

// ä¿å­˜å…ƒæ•°æ®ï¼ˆé™é»˜å¤±è´¥ï¼‰
fn save_metadata(metadata: &HashMap<String, FileMeta>, meta_file: &Path) {
    if let Ok(content) = serde_json::to_string_pretty(metadata) {
        let _ = fs::write(meta_file, content);
    }
}

// æ ¼å¼åŒ–å‰©ä½™æ—¶é—´
fn format_remaining(remaining: Duration) -> String {
    if remaining.num_seconds() <= 0 {
        return "Expired".to_string();
    }
    let days = remaining.num_days();
    let hours = remaining.num_hours() % 24;
    if days > 0 {
        format!("{} days left", days)
    } else {
        format!("{} hours left", hours.max(1))
    }
}

// åˆ é™¤å¤„ç†
fn handle_delete(
    path: &Path,
    expire_days: i64,
    force: bool,
    trash_dir: &Path,
    metadata: &mut HashMap<String, FileMeta>,
) {
    // è·å–ç»å¯¹è·¯å¾„ï¼ˆä¸è§£æç¬¦å·é“¾æ¥ï¼ï¼‰
    let path_abs = if path.is_absolute() {
        path.to_path_buf()
    } else {
        match std::env::current_dir() {
            Ok(cwd) => cwd.join(path),
            Err(e) => {
                eprintln!("âš ï¸  Skip '{}': Failed to get current dir: {}", path.display(), e);
                return;
            }
        }
    };

    // è·å–å…ƒæ•°æ®ï¼ˆä¸è§£æç¬¦å·é“¾æ¥ï¼‰
    let meta = match fs::symlink_metadata(&path_abs) {
        Ok(m) => m,
        Err(e) => {
            eprintln!("âš ï¸  Skip '{}': {}", path.display(), e);
            return;
        }
    };
    let is_symlink = meta.file_type().is_symlink();
    let file_type = if is_symlink {
        FileType::Symlink
    } else if meta.is_dir() {
        FileType::Dir
    } else {
        FileType::File
    };

    // ç³»ç»Ÿç›®å½•ä¿æŠ¤ï¼ˆè·³è¿‡ç¬¦å·é“¾æ¥ï¼‰
    if !force && !is_symlink {
        let system_paths = ["/bin", "/sbin", "/etc", "/usr", "/lib", "/lib64", "/root", "/boot"];
        let path_str = path_abs.to_str().unwrap_or("");
        if system_paths.iter().any(|p| path_str.starts_with(p)) {
            eprintln!("âŒ  Skip '{}': System directory protected (use -f to force)", path.display());
            return;
        }
    }

    let file_name = path_abs.file_name().unwrap().to_str().unwrap();
    let timestamp = SystemTime::now()
        .duration_since(SystemTime::UNIX_EPOCH)
        .unwrap()
        .as_nanos();
    let trash_name = format!("{}_{}", file_name, timestamp);
    let trash_path = trash_dir.join(&trash_name);

    println!("ğŸ“¤ Moving '{}' to trash (expire in {} days)...", path.display(), expire_days);
    if copy_path(&path_abs, &trash_path).is_err() || remove_path(&path_abs).is_err() {
        let _ = remove_path(&trash_path); // å›æ»š
        eprintln!("âŒ  Failed to move '{}' to trash", path.display());
        return;
    }

    metadata.insert(
        trash_name,
        FileMeta {
            original_path: path_abs,
            trash_path: trash_path.clone(),
            delete_time: Local::now().format("%Y-%m-%d %H:%M:%S").to_string(),
            expire_days,
            file_type,
        },
    );
    println!("âœ…  Moved to trash: {}", trash_path.display());
}

// æ¢å¤å¤„ç†
fn handle_restore(name: &str, force: bool, metadata: &mut HashMap<String, FileMeta>) {
    let Some(meta) = metadata.remove(name) else {
        eprintln!("âŒ  Restore '{}': Not found in trash", name);
        return;
    };

    if !meta.trash_path.exists() {
        eprintln!("âŒ  Restore '{}': Trash file not found", name);
        metadata.insert(name.to_string(), meta);
        return;
    }

    if meta.original_path.exists() && !force {
        eprintln!(
            "âŒ  Restore '{}': Target '{}' exists (use -f to force)",
            name,
            meta.original_path.display()
        );
        metadata.insert(name.to_string(), meta);
        return;
    }

    if force && meta.original_path.exists() {
        let _ = remove_path(&meta.original_path);
    }

    println!("ğŸ”„ Restoring '{}' to '{}'...", name, meta.original_path.display());
    if copy_path(&meta.trash_path, &meta.original_path).is_err() || remove_path(&meta.trash_path).is_err() {
        eprintln!("âŒ  Failed to restore '{}'", name);
        metadata.insert(name.to_string(), meta);
        return;
    }
    println!("âœ…  Restored: {}", meta.original_path.display());
}

// åˆ—è¡¨å±•ç¤º
fn handle_list(metadata: &HashMap<String, FileMeta>, expired: bool) {
    if metadata.is_empty() {
        println!("ğŸ—‘ï¸  Trash is empty");
        return;
    }

    println!("=== Safe-RM Trash List (Total: {}) ===", metadata.len());
    let now = Local::now();

    for (name, meta) in metadata {
        let delete_time = NaiveDateTime::parse_from_str(&meta.delete_time, "%Y-%m-%d %H:%M:%S").unwrap();
        let delete_time = Local.from_local_datetime(&delete_time).unwrap();
        let expire_time = delete_time + Duration::days(meta.expire_days);
        let remaining_dur = expire_time.signed_duration_since(now);

        if expired && remaining_dur.num_seconds() > 0 {
            continue;
        }

        let remaining_str = format_remaining(remaining_dur);
        println!("â–¶ Name: {}", name);
        println!(
            "  Type: {}",
            match meta.file_type {
                FileType::File => "File",
                FileType::Dir => "Directory",
                FileType::Symlink => "Symlink",
            }
        );
        println!("  Original: {}", meta.original_path.display());
        println!("  Delete Time: {}", meta.delete_time);
        println!("  Expire: {} ({})", meta.expire_days, remaining_str);
        println!("---------------------------");
    }
}

// æ¸…ç†å›æ”¶ç«™
fn clean_trash(metadata: &mut HashMap<String, FileMeta>, clean_all: bool) {
    let now = Local::now();
    let to_remove: Vec<String> = metadata
        .iter()
        .filter(|(_, meta)| {
            clean_all
                || {
                    let delete_time =
                        NaiveDateTime::parse_from_str(&meta.delete_time, "%Y-%m-%d %H:%M:%S").unwrap();
                    let delete_time = Local.from_local_datetime(&delete_time).unwrap();
                    let expire_time = delete_time + Duration::days(meta.expire_days);
                    now > expire_time
                }
        })
        .map(|(name, _)| name.clone())
        .collect();

    for name in to_remove {
        if let Some(meta) = metadata.remove(&name) {
            let _ = remove_path(&meta.trash_path);
            println!("ğŸ—‘ï¸  Cleaned: {}", name);
        }
    }
}

// æ£€æŸ¥è¿‡æœŸæ—¶é—´
fn handle_expire(name: &str, metadata: &HashMap<String, FileMeta>) {
    let Some(meta) = metadata.get(name) else {
        eprintln!("âŒ  '{}' not found in trash", name);
        return;
    };

    let delete_time = NaiveDateTime::parse_from_str(&meta.delete_time, "%Y-%m-%d %H:%M:%S").unwrap();
    let delete_time = Local.from_local_datetime(&delete_time).unwrap();
    let expire_time = delete_time + Duration::days(meta.expire_days);
    let remaining_dur = expire_time.signed_duration_since(Local::now());

    println!("=== Expire Info for '{}' ===", name);
    println!("Original Path: {}", meta.original_path.display());
    println!("Delete Time: {}", meta.delete_time);
    println!("Expire Time: {}", expire_time.format("%Y-%m-%d %H:%M:%S"));

    if remaining_dur.num_seconds() > 0 {
        println!(
            "Remaining Time: {} days, {} hours",
            remaining_dur.num_days(),
            remaining_dur.num_hours() % 24
        );
    } else {
        println!("Status: Expired ({} hours ago)", -remaining_dur.num_hours());
    }
}

// æ¸…ç©ºå›æ”¶ç«™
fn handle_empty(yes: bool, metadata: &mut HashMap<String, FileMeta>) {
    if !yes {
        print!("âš ï¸  Are you sure to empty trash (permanent delete all)? [y/N]: ");
        std::io::stdout().flush().unwrap();
        let mut input = String::new();
        std::io::stdin().read_line(&mut input).unwrap();
        if !input.trim().eq_ignore_ascii_case("y") {
            println!("âœ…  Canceled");
            return;
        }
    }

    for (name, meta) in metadata.drain() {
        let _ = remove_path(&meta.trash_path);
        println!("ğŸ—‘ï¸  Deleted: {}", name);
    }
    println!("âœ…  Trash emptied completely!");
}

fn main() {
    let home = home_dir().expect("Failed to get home directory");
    let trash_dir = home.join(TRASH_DIR);
    let meta_file = home.join(META_FILE);
    fs::create_dir_all(&trash_dir).expect("Failed to create trash directory");

    let mut metadata = load_metadata(&meta_file);
    clean_trash(&mut metadata, false);
    save_metadata(&metadata, &meta_file);

    let cli = Cli::parse();
    match cli.cmd {
        Commands::Delete { paths, expire_days, force } => {
            for path in paths {
                handle_delete(&path, expire_days, force, &trash_dir, &mut metadata);
            }
        }
        Commands::Restore { names, force } => {
            for name in names {
                handle_restore(&name, force, &mut metadata);
            }
        }
        Commands::List { expired } => {
            handle_list(&metadata, expired);
        }
        Commands::Clean { all } => {
            clean_trash(&mut metadata, all);
            println!("Clean completed!");
        }
        Commands::Expire { name } => {
            handle_expire(&name, &metadata);
        }
        Commands::Empty { yes } => {
            handle_empty(yes, &mut metadata);
        }
    }

    save_metadata(&metadata, &meta_file);
}